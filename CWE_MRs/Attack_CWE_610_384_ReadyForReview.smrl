import static smrl.mr.language.Operations.*;
import smrl.mr.language.Action;

package smrl.mr.owasp{

/**
 * CWE Definition:
 * Authenticating a user, or otherwise establishing a new user session, without invalidating any
 * existing session identifier gives an attacker the opportunity to steal authenticated sessions.
 * 
 * A web application authenticates a user without first invalidating the existing session, thereby
 * continuing to use the session already associated with the user. An attacker is able to force a known
 * session identifier on a user so that, once the user authenticates, the attacker has access to the 
 * authenticated session. The application or container uses predictable session identifiers. In the 
 * generic exploit of session fixation vulnerabilities, an attacker creates a new session on a web 
 * application and records the associated session identifier. The attacker then causes the victim to 
 * associate, and possibly authenticate, against the server using that session identifier, giving the 
 * attacker access to the user's account through the active session.
 * 
 * Comments: 
 * (1) The first loop iterates over all the actions to find a login action.
 * (2) The second loop iterates over all the actions to find an action performed after login.
 * (3) Checks if the current action y is a login operation.
 * 
 * FABRIZIO: In my opinion we shall simply perform a login within another logged in session. No logout is needed.
 * 
 * (4) Defines a follow-up input with the sequence of two logins.
 * (5) Verifies that the system assigns different session IDs after the login,
 * (6) Checks that the previous session ID is not valid anymore.
 *   
 */ 
MR CWE_610_384 {
		{
			for ( var x = 0; x < Input(1).actions().size(); x++ ){   //(1)
		
				for ( var y = x+1; isLogin(Input(1).actions().get(x)) && (y < Input(1).actions().size()); y++){  //(2)
					
					//var sessionID =  Output(Input(1),x).getSession()
					setResetBrowserBetweenInputs( false );
					//TODO: automating he invocation of setResetBrowserBetweenInputs( false ) could be an improvement to the language
					//but the problem is also that, to specify the follow-up input, we need to partially execute it (we execute Input(2) before specifying Input(3)
					//For this reaosn it might not be straightforward
					//Event better, we may provide a feature to specify which browser to use in order to execute an input. That way we will be able to simulate parallel execution
					//For that, we need to check if we can start two drivers
					 
					//Input(1) L A B C D
					
					//Input(2) L A B 
					//Input(3) L C D
					
					IMPLIES ( 
						EQUAL ( Input(2) , Input ( Input(1).actions().subList(0, y ) ) ) && //(4)
						EQUAL ( Input(3) , Input ( Input(1).actions().subList(y, Input(1).actions().size() ) ) )  && //(4)
						Input(3).addAction(0,Input(1).actions().get(x)) && //we start with a login
						Input(3).actions().get(1).setSession( Output(Input(2),x).getSession() ) //however, after the login we are forcing the browser to reuse the old session ID
						
						
						
						//EQUAL(Input(3), addAction(Input(2), y+1, Input(1).actions().get(y)))
						 // configure the system to do not reset the state of selenium 
						, 
						//FABRIZIO: nou sure if it is "x" or "x+1"
						AND( different ( Output(Input(2),x).getSession(),  Output(Input(3),0).getSession() ) //(5)
						,
						TRUE(Output(Input(3),1).getSession().isInvalid()) //(6)  //FABRIZIO: what is this supposed to do? 
						                                                   //Nazanin: checks that the previous login(x) session has been invalidated (terminated).
																		   //FABRIZIO: from technical perspect it does not appear to be feasible. MST work at the client side. You have no easy way to check if the session is valid, how do you plan to do it, concretely?
																		   //Nazanin: Actually from the following website I assume that we can use the session.status to be "failed" or "timeout".
																		   // https://www.browserstack.com/docs/automate/api-reference/selenium/session#get-session-list
																		   // I also saw this on webdriver api documentation:
																		   // exception selenium.common.exceptions.InvalidSessionIdException(msg=None, screen=None, stacktrace=None) //Bases: selenium.common.exceptions.WebDriverException
																		   //Occurs if the given session id is not in the list of active sessions, meaning the session either does not exist or that itï¿½s not active.
						)
					); //end-IMPLIES
					
					setResetBrowserBetweenInputs( true ); //FIXME: shall this be automatically performed by the framework?
					
				} //end-for
			} //end-for
		}
	} //end-MR
} //end-package

